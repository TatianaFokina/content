---
title: "`@layer`"
description: "Управляем каскадными слоями с помощью чистого CSS."
authors:
  - tatianafokina
keywords:
  - ＠-правило
  - поддержка свойств
  - feature queries
  - CSS at-rule
  - cascade layers
  - layer ordering
  - CSS layers
  - CSS-слои
related:
  - css/has
  - css/where
  - css/import
tags:
  - doka
---

## Кратко

Директива `@layer` даёт вам управлять каскадными слоями — способом группировки и порядком применения стилей в одном источнике. Благодаря таким слоям браузеры решают, какие стили применить на сайте.

Источник в CSS — место, откуда браузер берёт [CSS-правила](/css/css-rule/). Это могут быть ваши стили на сайте, настройки пользователей в браузере и системе, а также браузерные стили по умолчанию. Подробнее об этой и других концепциях узнаете из статьи «[Принцип каскада](/css/cascade/)».

С помощью `@layer` вы напрямую управляете слоями с разными наборами CSS-правил и решаете, какие стили специфичнее и в каком порядке их применять. Так что `@layer` пригодится для:

- сброса браузерных стилей по умолчанию;
- перезаписи стилей из CSS-фреймворков и библиотек;
- стилизации компонентов;
- хранения стилей в одном месте, например, для состояний интерактивных элементов;
- цветовых тем, схем и поддержки разных режимов передачи цветов.

<aside>

⚠️ Следите за размером итогового файла со стилями, когда используете `@layer`. С этой директивой легко на выходе получить файл с большим количеством CSS-правил, которые перезаписыват друг друга.

</aside>

## Пример

Стили с `@layer` для состоянии кнопки при фокусе и когда она нективна. В слое `states` устанавливаем стили для `:disabled` и `:focus-visible`, а в `components` — стили кнопки по умолчанию.

```css
@layer components, states;

@layer components {
  .button {
    display: block;
    min-width: 210px;
    border: 2px solid transparent;
    border-radius: 6px;
    padding: 9px 15px;
    color: #000000;
    font-size: 18px;
    font-weight: 300;
    font-family: inherit;
    transition: background-color 0.2s linear;
  }

  .button:hover {
    background-color: #FFFFFF;
    cursor: pointer;
    transition: background-color 0.2s linear;
  }
}

@layer states {
  :disabled {
    background-color: #DDDDDD;
  }

  :focus-visible {
    border: 2px solid #FFFFFF;
    outline: none;
  }
}
```

<iframe title="Кнопка с разными состояниями" src="demos/button-states/" height="250"></iframe>

В этом примере определяем стили для светлой и тёмной темы с помощью `@layer`.

```css
@layer theme {
  @layer light, dark;

  @layer light {
    body {
      --background: #FFFFFF;
      --color: #000000;

      background-color: var(--background);
      color: var(--color);
    }
  }
}

@media (prefers-color-scheme: dark) {
  @layer theme.dark {
    body {
      --background: #000000;
      --color: #FFFFFF;
    }
  }
}
```

## Как пишется

Есть несколько способов объявления каскадных слоёв:

- через директиву `@layer`;
- через ключевое слово `layer` или функцию `layer()`.

Вне зависимости от способа объявления, слои могут быть с именем (названными) и без него (анонимные).

С помощью названных слоёв напрямую управляете порядком стилей или определяете его в одном месте в файле со стилями.

Анонимные слои помогают использовать правила из одного слоя повторно, для нескольких элементов, а ещё не дают другим разработчикам манипулировать стилями в них. Это особенно полезно, когда заменяете стили CSS-фреймворка на свои.

### Директива `@layer`

Для **названных слоёв** укажите имя после директивы `@layer`, а внутри перечислите нужные правила. Имя слоя может быть любым на латинице. К примеру, `project`, `override`, `framework`, `base`, `utilities` или `theme`. Имена должны быть уникальными и не повторяться. Исключение — когда они вложены друг в друга.

```css
@layer any-layer-name {
  /* Одно или несколько CSS-правил */
}
```

Слои можно вкладывать в друг друга. Слой с другими внутри называется родительским, а вложенные в него — дочерними. Обратите внимание, что вложенный слой не может «выйти за пределы» своего родителя и быть связанным с другими родительскими или дочерними слоями.

Здесь слой `framework` — родительский, а `base` и `theme` — дочерние.

```css
@layer framework {
  @layer base {
    /* Одно или несколько CSS-правил */
  }

  @layer theme {
    /* Одно или несколько CSS-правил */
  }
}
```

У дочерних слоёв могут быть такие же имена, как у других за пределами его родителя. К примеру, здесь два совершенно разных слоя: `base` и `framework.base`.

```css
@layer base {
  /* Одно или несколько CSS-правил */
}

@layer framework {
  @layer base {
    /* Одно или несколько CSS-правил */
  }
}
```

Слои можно перечислять в одном месте. Расположите их имена через запятую после директивы `@layer`.

```css
@layer layer-1, layer-2;

@layer layer-1 {
  /* Одно или несколько CSS-правил */
}

@layer layer-2 {
  /* Одно или несколько CSS-правил */
}
```

При перечислении дочерних слоёв после директивы `@layer` сначала укажите название родительского, а через точку — дочернего, который вложен внутрь родительского.

К примеру, тут родительский слой `framework`, а дочерние — `base` и `theme`, поэтому при перечислении они станут `framework.base` и `framework.theme`.

```css
@layer framework.base, framework.theme;

@layer framework {
  @layer base {
    /* Одно или несколько CSS-правил */
  }

  @layer theme {
    /* Одно или несколько CSS-правил */
  }
}
```

Слои можно перечислять и внутри `@layer`. В этом случае название слоя снова складывается из имени родителя и ребёнка. К примеру, есть слой `framework`, в котором определяем порядок применения базовых стилей `base` и стилей для тёмной темы `theme`. В этом случае сами стили будем хранить в слоях `framework.base` и `framework.theme`.

```css
@layer framework {
  @layer base, theme;
}

@layer framework.base {
  /* Одно или несколько CSS-правил */
}

@layer framework.theme {
  /* Одно или несколько CSS-правил */
}
```

В `@layer` можно вкладывать и другие директивы. Например, [`@media`](/css/media/).

```css
@layer framework {
  html {
    color: #000000;
    background: #FFFFFF;
  }

  @media (prefers-color-scheme: dark) {
    html {
      color: #FFFFFF;
      background: #000000;
    }
  }
}
```

Для **анонимных слоёв** указывайте только директиву `@layer` с нужными правилами внутри.

```css
@layer {
  /* Одно или несколько правил */
}
```

В анонимные слои можно добавлять названные. Другие разработчики всё ещё не могут манипулировать этими стилями, так как их родитель — анонимный слой.

```css
@layer {
  @layer base {
    /* Одно или несколько правил */
  }

  @layer typography {
    /* Одно или несколько правил */
  }
}
```

#### Как работает

На то, в каком порядке применяются стили слоёв, влияет порядок их расположения в файле или в списке. Также есть особенности поведения CSS-правил и внутри самих слоёв.

В слое с CSS-правилами и ещё одним `@layer` выигрывают отдельные правила. В этом примере текст параграфа будет чёрным (`#000000`), так как это правило за пределами дочернего слоя.

```css
@layer typography {
  /* Я победил 🥇 */
  p {
    color: #000000;
  }

  /* Я проиграл */
  @layer content;
}

@layer typography.content {
  p {
    color: #FFFFFF;
  }
}
```

Чтобы избежать путаницы, можно всегда выносить такие правила за пределы `@layer`.

```css
/* Я победил 🥇 */
p {
  color: #000000;
}

/* Я проиграл */
@layer typography {
  @layer content;
}

@layer typography.content {
  p {
    color: #FFFFFF;
  }
}
```

Когда правила не вложены внутрь `@layer`, они всегда побеждают. Например, здесь текст будет чёрным, несмотря на стили для класса `.text--pink` в `@layer`.

```html
<p class="text--pink">
  Хроносинкластический инфундибулум!
</p>
```

```css
/* Я проиграл */
@layer typography {
  .text--pink {
    color: #F498AD;
  }
}

/* Я победил 🥇 */
p {
  color: #000000;
}
```

<iframe title="Вычисление стилей вне @layer" src="demos/layer-vs-unleared-rules/" height="250"></iframe>

Такое правило применится даже если расположено выше `@layer`, так что текст всё ещё остаётся чёрным.

```css
/* Я победил 🥇 */
p {
  color: #000000;
}

/* Я проиграл */
@layer typography {
  .text--pink {
    color: #F498AD;
  }
}
```

А что будет, если у правил в слоях указано [`!important`](/css/important/)? В этом случае порядок определяется следующим образом:

1. Слой, который расположен выше других.
1. Правило вне `@layer`.
1. Слой без правил с `!important`.

```css
/* Я победил 🥇 */
@layer typography {
  .text--pink {
    color: #F498AD !important;
  }
}

/* Я проиграл */
p {
  color: #000000 !important;
}

/* Я тоже проиграл */
@layer typography {
  p {
    color: #FFFF !important;
  }
}
```

На порядок вычисления стилей при перечислении слоёв после директивы `@layer` влияет то, где они расположены в строке. Первый слой в списке перезаписывается слоем после него и так далее.

В примере текст параграфа [`<p>`](/html/p/) снова будет чёрным, так как слой `layer-2` находится после `layer-1` и, соответстственно, выше в порядке представления.

```css
@layer layer-1, layer-2;

/* Я проиграл */
@layer layer-1 {
  p {
    color: #FFFFFF;
  }
}

/* Я победил 🥇 */
@layer layer-2 {
  p {
    color: #000000;
  }
}
```

Даже если повысить специфичность параграфа из слоя `layer-1` с помощью `id`, `layer-2` всё равно будет располагаться выше, так что текст в параграфе останется чёрным.

```css
@layer layer-1, layer-2;

/* Я проиграл */
@layer layer-1 {
  p#light {
    color: #FFFFFF;
  }
}

/* Я победил 🥇 */
@layer layer-2 {
  p {
    color: #000000;
  }
}
```

С дочерними слоями при перечислении всё работает точно так же. В этом примере у нас есть родитель `framework` и два ребёнка `framework.base` и `framework.theme`. Текст параграфа снова будет чёрным, так как `framework.theme` в списке расположен после `framework.base`.

```css
@layer framework.base, framework.theme;

@layer framework {
  /* Я победил 🥇 */
  @layer theme {
    p {
      color: #000000;
    }
  }

  /* Я проиграл */
  @layer base {
    p {
      color: #FFFFFF;
    }
  }
}
```

В случае анонимных слоёв важно, где они находятся в файле. Так что вы не можете добавить их в любое место, как названные слои.

В примере анонимный слой расположен перед названным `base`, поэтому текст параграфа — чёрный.

```css
/* Я проиграл */
@layer {
  p {
    color: #FFFFFF;
  }
}

/* Я победил 🥇 */
@layer base {
  p {
    color: #000000;
  }
}
```

Чтобы текст стал белым, надо расположить его после `base`.

```css
/* Я проиграл */
@layer base {
  p {
    color: #000000;
  }
}

/* Я наконец-то победил 🥇 */
@layer {
  p {
    color: #FFFFFF;
  }
}
```

### Ключевое слово `layer`

Ключевое слово `layer` пригодится, когда работаете со сторонними стилями и используете директиву `@import`. В примере перезаписываем нужные стили в файле `tailwind.css` стилями из анонимного слоя. Анонмный слой можно расположить перед или после `@import`. Результат будет одинаковым.

```css
@layer {
  /* Одно или несколько правил */
}

@import url(tailwind.css) layer;
```

```css
@import url(tailwind.css) layer;

@layer {
  /* Одно или несколько правил */
}
```

Правила из анонимных слёв можно применить для нескольких файлов. В этом примере образаемся к анонимному слою для `base-forms.css`, `base-links.css` и `base-buttons.css`.

```css
@import url(base-forms.css) layer;
@import url(base-links.css) layer;
@import url(base-buttons.css) layer;

@layer {
  /* Одно или несколько правил */
}
```

### Функция `layer()`

С помощью функции `layer()` можно оразаться к конкретному слою, как названному, так и анонимному.

Представим, что нам нужно добавить свои базовые стили для сайта, на котором так же используем Bootstrap. В этом случае можете создать слой `base` и использовать его в файле `bootstrap.css`.

```css
@import url(bootstrap.css) layer(base);

@layer base {
  p {
    color: #FFFFFF;
  }
}
```

Один слой может переопределять стили в нескольких ситуациях. Связывает несколько блоков со стилями с одним слоем. В примере стили из файлов headings.css и links.css соскадированы с одним и тем же слоем default:

```css
@import url(headings.css) layer(default);
@import url(links.css) layer(default);

@layer default {
  audio[controls] {
    display: block;
  }
}
```

В случае анонимных слоёв также можно обращаться к их дочерним слоям с именами. В этом случе у нас есть доступ к слою base, но не к анонимному родительскому. Он так и остётмя анонимным.

Представим, что нам нужно добавить свои базовые стили для сайта, на котором так же используем Bootstrap. В этом случае можете создать слой `base` и использовать его в файле `bootstrap.css`.

```css
@import url(bootstrap.css) layer(base);

@layer {
  @layer base {
    /* Одно или несколько правил */
  }
}
```

Можно использовать `@layer` для объявления слоёв, отформатированных как многострочные или однострочные. Эта функция позволяет вам определять порядок слоёв в одном месте вверху своих стилей. Затем они смогут добавлять стили позже с помощью методов блока или импорта, ссылаясь на то же имя слоя.

В этом примере мы, по сути, даем стилям платформы Bootstrap самый низкий приоритет в качестве слоя, за которым следуют наши собственные базовые стили и, наконец, разрешаем уровень приложения.

```css
@layer bootstrap, base, application;

@import url(bootstrap.css) layer(bootstrap);

@layer base {
  body {... }
}
```

Как только вы добавите @layer после @import, любое использование @import после этого слоя будет недопустимым и не будет загружено. Итак, если вам нужно добавить несколько @import, вам нужно будет сгруппировать их, прежде чем создавать больше слоев.

Если нужно связать несколько слоёв с файлом, перечислите их в той же директиве @import через запятую в нужном порядке:

```css
@import url(framework.css) layer(bootstrap), layer(tailwind);
```

## Как понять

Слои в CSS похожи на слои в редакторах изображений вроде PhotoShop. В этой программе у фотографии может быть несколько слоёв с разными фильтрами и ретушью, но при этом они не смешиваются друг с другом, прозрачные и складываются в одну картинку.

Это решает проблему со стилями без изменения селекторов или увеличения их специфичности, а также избегать конфликтов между разными слоями и их стилями из-за их расположения в файле. Часто они возникают, когда в вашем проекте несколько источников стилей. Например, используете фреймворки и библиотеки.

Это полезно в случае больших проектов и когда используете сторонние стили, препроцессоры, фреймворки.
